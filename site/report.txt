<ul>
<li>**A for HTML**</li>
We believe we have gained a high level of confidence using HTML, ensuring correct HTML is used with XHTML delivery and occasional use of the validator we have created using a bash script. We have made sure AngularJS is within the syntax for XHTML.
<li>**A for CSS**</li>
We believe that we have efficiently used Bootstrap CSS to provide a Mobile-First structure and design of our web pages. We believe we have a high amount of confidence using CSS, especially when using the grid system within Bootstrap. We have a custom CSS file that either creates new styles or overwrites certain aspects of Bootstrap using the !important syntax.
<li>**A for JS**</li>
We believe that with the use of AngularJS we have complete control and understanding of the client-side, including the use of ui-router to make our website a Single-Page-Application (deals with routing without refreshing but switching views). AngularJS has provided us with a MVC design that is very helpful in handling user interactions.
<li>**A for PNG**</li>
We have 3 PNGs that demonstrate a simple and sophisticated use of tools. For all of our PNGs, we use a number of layers to control overlay. We also heavily used the transform tools to be able to scale and move around components of the overall PNG. Using Gimp, we export to PNG from the .xcf format. When combining images together, we often have to extend the canvas size so all the PNGs inside the file fit.
<ol>
<li>For the PNG on the homepage (header.png), this consists of a PNG imported in (icon.png) but put on a separate layer. We used a textured background found in GIMP, and the text tool to provide the header title. Within the icon itself, we used the Rectangle shape tool to create the border and filled these shapes in using the Bucket Fill tool. We used the text tool once again and imported another PNG image (book.png) that is once again found on another layer. We used the airbrush tool, with imported Splatter Brush shapes, to produce the background of the icon. </li>
<li>For the first PNG on the About Us page, we once again used a textured background found in GIMP and the text tool. We imported another PNG (the bear) inside to a different layer, and made sure this was on top of the original layer so that it could be seen. </li>
<li> For the second PNG on the About Us page, we used more advanced tools to show off our understanding of GIMP. We used the airbrush tool heavily, creating a border around the perimeter, and an inside border around the text. We then used the Dissolve filter on the inside border to provide a dotty texture. We used the airbrush tool and the imported Splatter Brush shapes to provide stroke marks either side of the text, and then used a different Splatter Brush shape to paint the background of the text. This background is set to an opacity of 60% to give it some transparency. </li>
</ol>
Overall, we believe we have gained a good understanding of GIMP and are very confident in producing artwork. We have tried to ensure our images fit in the theme of a children's learning resource.
<li>**A for SVG**</li>
We have created 6 SVGs using Inkscape, where all of these are Profile Icons found in the Dashboard "Change Profile Icon". For all images, we used the tranformations tool box to scale and rotate objects. To help transform objects that had separate components, we used the grouping options to group related objects. This allowed us to scale the whole dog correctly, which consisted of many separate bezier curves until we grouped it.
<ol>
<li>For the first 3 SVGs (bear, cat and dog), these all use the same techniques. We imported JPEGs into Inkscape and set the opacity of this JPEG to 50% so that we could see our pen marks over it. We used these JPEGs are trace sheets. When importing these, we had to use the transformation tool box to scale the images to fit onto the layer. We used bezier curve tools to created curved pen marks, using the handles to provide a greater or shallower curve. This tool allowed me to create ellipse-like shapes and straight lines. We used the object stroke and fill option to colour the bezier curve tool, and fill in shapes. We used the circular tool to create accurate, symmetrical circles (like the eyes). We used the spiral tool on the dog SVG to provide patterns.</li>
<li>For the fourth SVG, we used the Object to Pattern tool to create a patterned background on the circular shapes (created using the circular tool). We used the gradient fill tool to create radial gradient colourings on the stars (created using the star tool).</li>
<li>For the fifth SVG, we created our own gradient using the gradient tool where you dragged a line to provide the amount of gradient you wanted. We used the brush tool to draw the letter A.</li>
<li>For the last SVG, we used the text tool. We also used layers within this SVG - this allowed us to lay objects over each other. For example, I wanted text to rest on top of a polygon shape, and so created a new layer that was above the other layer (using the layer raise option) and added the text to this new layer. We also used the blur tool for the polygon edges.</li>
</ol>
Overall, we believe we have gained a lot of experience using Inkscape and creating SVGs, using a lot of sophisticated tools in the correct way to provide nice vector artwork.
<li>**A for Server**</li>
We believe we have put a lot of effort into our server-side, using the Express framework to create our own, secure API. We have a HTTPS server using self-signed SSL certificates (generated using OpenSSL), and have a HTTP server that just re-directs to the HTTPS server. Just a quick side note, the certificate may need to be trusted on your own computer using the Keychain facility to be able to access our web pages on Chrome / Firefox. We had a problem where Chrome updated and invalidated our certificate, but believe this has been fixed by using extra options within OpenSSL. Our HTTPS connection means POSTs to the API are secure. Passwords are hashed and stored in the embedded database. We are using Token Authentication to keep track of login sessions where we cryptographically sign JSON Web Tokens, encrypted to prevent tampering on the client side. These tokens are stored in Local Storage and we have an Angular client-side helper that checks to make sure the token hasn't expired. These Web Tokens are efficient because they reduce the need to communicate the server constantly to check if the user is logged in. They are also verified on the server when using the API and certificate before accessing protected routes. Our server is written using Typescript to reduce errors and provide minified JavaScript.
<li>**A for Database**</li>
We have formed our embedded database with the following tables; UserAccounts, Comments, Pages, and Canvases. We have used SQL to insert, update, delete and get data (select) from the database. We have also used more advanced SQL such as joins to merge rows from different tables. This has allowed us to reduce unnecessarily storing data that exists in other tables. We have also used Node's SQLite functionality for serially running queries. This was necessary because when inserting a new page to the database we needed to access an auto-generated and incremented ID of the newly inserted page. Node's SQLite originally acts asynchronously, and hence we couldn't run the INSERT and the GET as they would execute in parallel. The db.serialize function allowed us to run the INSERT and then the GET. We believe we have gained a lot of experience with SQL.
<li>**A for Dynamic pages**</li>
Our website relies heavily on requesting data from the server and inserting into existing pages on the client side. Using services in Angular we pull data from the API using HTTPS requests. For example, in the My Comments section in the Dashboard all the user's comments are pulled from the API and dynamically loaded into the table. We have written a Markdown parser that converts Markdown into HTML. Users can therefore create their own pages written in Markdown. The server parses the Markdown into HTML, and returns the HTML which can just be put straight into a template div. This means that we are dynamically delivering converted HTML using Angular's ng-bind-html directive, but also dynamically delivering strings, like comments or page information, just using ng-bind. We believe this shows we have become very fluent in the use of AngularJS to dynamically load data into pages client-side.
<li>**X for Depth (out of 40)**</li>
</ul>
