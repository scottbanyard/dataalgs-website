This is *dataalgs*, a data structures and algorithms site intended as a childrens' learning resource. It revolves around user-created pages and images.  

The stack for this site is AngularJS at the front end, Express for the routing, a NodeJS server and an SQL Database. Typescript has been used throughout all non-Angular code, so as to leverage the advantages offered to programmers by some manner of compile-time typechecking.

<ul>
<li>**A for HTML**</li>
We have gained a high level of confidence using HTML, ensuring correct HTML is used with XHTML delivery and use of the validator we have created using a bash script. The validator has helped us provide clean HTML files, spotting obselete and missing attributes, stray tags, and unclosed elements. We have made sure AngularJS is written within the syntax for XHTML by providing the 'data-' syntax before any 'ng-X' directives.

<li>**A for CSS**</li>
We have used Bootstrap CSS to provide a Mobile-First structure and design of our web pages. We believe we have a high amount of confidence using CSS, especially when using the grid system within Bootstrap. We have use a custom CSS file to augment the Bootstrap styling where necessary, overwriting certain aspects of Bootstrap using the !important syntax.

<li>**A for JS**</li>
We believe that with the use of AngularJS we have complete control and understanding of the client-side, including the use of ui-router to make our website a Single-Page-Application (deals with routing without refreshing but switching views). AngularJS has provided us with a MVC design that is very helpful in handling user interactions. We have used services within the Angular framework to send https requests to the server-side, where that uses the Express framework to control the routing (our API). We have used Typescript extensively for more heavy-weight programming tasks, which will be described below.

<li>**A for PNG**</li>
We have 3 PNGs that demonstrate the simple and sophisticated use of tools within GIMP. For all of our PNGs, we used a number of layers to control overlay. We also heavily used the transform tools to be able to scale and move around components of the overall PNG. Using Gimp, we export to PNG from the .xcf format. When combining images together, we often have to extend the canvas size so all the PNGs inside the file fit.
<ol>
<li>For the PNG on the homepage (header.png), this consists of a PNG imported in (icon.png) but put on a separate layer. We used a textured background found in GIMP, and the text tool to provide the header title. Within the icon itself, we used the Rectangle shape tool to create the border and filled these shapes in using the Bucket Fill tool. We used the text tool once again and imported another PNG image (book.png) that is once again found on another layer. We used the airbrush tool, with imported Splatter Brush shapes, to produce the background of the icon. </li>
<li>For the first PNG on the _About Us_ page, we once again used a textured background found in GIMP and the text tool. We imported another PNG (the bear) inside to a different layer, and made sure this was on top of the original layer so that it could be seen. </li>
<li> For the second PNG on the _About Us_ page, we used more advanced tools to show off our understanding of GIMP. We used the airbrush tool heavily, creating a border around the perimeter, and an inside border around the text. We then used the Dissolve filter on the inside border to provide a dotty texture. We used the airbrush tool and the imported Splatter Brush shapes to provide stroke marks either side of the text, and then used a different Splatter Brush shape to paint the background of the text. This background is set to an opacity of 60% to give it some transparency. </li>
</ol>
Overall, we believe we have gained a good understanding of GIMP and are very confident in producing artwork. We have tried to ensure our images fit in the theme of a children's learning resource.

<li>**A for SVG**</li>
We have created 6 SVGs using Inkscape, all of being Profile Icons found in the Dashboard's "Change Profile Icon" section. For all images, we used the tranformations tool box to scale and rotate objects. To help transform objects that had separate components, we used the grouping options to group related objects. This allowed us to scale the whole dog correctly, it having consisted of many separate bezier curves until we grouped it.
<ol>
<li>For the first 3 SVGs (bear, cat and dog), these all use the same techniques. We imported JPEGs into Inkscape and set the opacity of this JPEG to 50% so that we could see our pen marks over it. We used these JPEGs as trace sheets. When importing these, we had to use the transformation tool box to scale the images to fit onto the layer. We used bezier curve tools to created curved pen marks, using the handles to provide a greater or shallower curve. This tool allowed us to create ellipse-like shapes and straight lines. We used the object stroke and fill option to colour the bezier curve tool, and fill in shapes. We used the circular tool to create accurate, symmetrical circles (like the eyes). We produced patterns on the dog using the spiral tool.
</li>
<li>For the fourth SVG, we used the Object to Pattern tool to create a patterned background on the circular shapes (created using the circular tool). We used the gradient fill tool to create radial gradient colourings on the stars (created using the star tool).</li>
<li>For the fifth SVG, we created our own gradient using the gradient tool dragging a line to provide the desired gradient. We used the brush tool to draw the letter A.</li>
<li>For the last SVG, we used the text tool. We also used layers within this SVG; the text is made to rest on top of a polygon through creating another layer above the other (using the layer raise option), adding the text to this layer. We also used the blur tool for the polygon edges.
</li>
</ol>
Overall, we believe we have gained a lot of experience using Inkscape and creating SVGs, using a lot of sophisticated tools in the correct way to provide nice vector artwork.

<li>**A for Server**</li>
We believe we have put a lot of effort into our server-side, using the Express framework to create our own, secure API. We have an HTTPS server using self-signed SSL certificates (generated using OpenSSL). Just a quick side note, the certificate may need to be trusted on your own computer using the Keychain facility to be able to access our web pages on Chrome / Firefox. We had a problem where Chrome updated and invalidated our certificate, but believe this has been fixed by using extra options within OpenSSL. Our HTTPS connection means POSTs to the API are secure. When a user registers a new account, a cryptographically secure salt is generated (using the csprng node library). Passwords are then hashed using sha256. These salts and hashed passwords are then stored in the embedded database. We are using Token Authentication to keep track of login sessions, signing and encrypting JSON Web Tokens to prevent client-side tampering. These tokens are stored in Local Storage and we have an AngularJS client-side helper that checks to make sure the token hasn't expired. These Web Tokens are efficient because they reduce the need to communicate the server constantly to check if the user is logged in. They are also verified on the server when using the API and certificate before accessing protected routes. Our server is written using Typescript to reduce errors and provide minified JavaScript. We have also gone a bit further to ensure people are using the HTTPS secure protocol by re-directing those accessing the HTTP version of the website.

<li>**A for Database**</li>
We have formed our embedded database with the following tables: UserAccounts, user details such as password hashes; Comments, storing comments themselves as well as user and page ids; Pages, which contains information about creators of pages, the markdown of each page, as well as view and edit permissions; and Canvases, the information about created images. We have used SQL to insert, update, delete and get data (select) from the database. We have also used more advanced SQL such as joins to merge rows from different tables. This has allowed us to reduce unnecessarily storing data that exists in other tables. We have also used Node's SQLite functionality (using [sqlite3](https://www.npmjs.com/package/sqlite3) ) for serially running queries. This was necessary because when inserting a new page to the database we needed to access an auto-generated and incremented ID of the newly inserted page. Node's SQLite originally acts asynchronously, and hence we couldn't run the INSERT and the GET as they would execute in parallel. The db.serialize function allowed us to run the INSERT and then the GET. We have also put the database functionality in its own module so that it can be easily maintained. We believe we have gained a lot of experience with SQL.

<li>**A for Dynamic pages**</li>
Our website relies heavily on requesting data from the server and inserting into existing pages on the client side. Using services in Angular we pull data from the API using HTTPS requests. For example, in the My Comments section in the Dashboard all the user's comments are pulled from the API and dynamically loaded into the table. We have written a Markdown parser that converts Markdown into HTML. Users can therefore create their own pages written in Markdown. The server parses the Markdown into HTML, and returns the HTML which can just be put straight into a template div. This means that we are dynamically delivering converted HTML using Angular's ng-bind-html directive, but also dynamically delivering strings, like comments or page information, just using ng-bind. We believe this shows we have become very fluent in the use of AngularJS to dynamically load data into pages client-side.

<li>**A for Depth (out of 40)**</li>
We have claimed an A for Depth as we are proud of our achievements with user-created pages. User creation comes in two main forms: the creation of images using a custom canvas element; the creation of pages using a markdown editor.

The image creation page uses an HTML canvas element, colour picker, and a choice of shapes to draw: Lines and Arrows are created by click and dragging on the canvas; Squares and Circles are input through clicking, and a text input box (using a library [CanvasInput](http://goldfirestudios.com/blog/108/CanvasInput-HTML5-Canvas-Text-Input) ). Any actions on the canvas are relayed to the model, CanvasState. This maintains the current state of the canvas, as well as checking for interaction between the user and previously extant shapes and is in charge of rendering. This is written in Typescript, compiled to Javascript, so as to allow for more type-structured programming style than encouraged by Javascript. Users can also download the images created, as PNGs. Of particular interest with the image editor:

<ul>
    <li> 
        In order to support both click actions and click-and-drag actions, there are a trio of functions fired on the _onmousedown_, _onmousemove_ and _onmouseup_ event. When dragging a shape, various states needs to be maintained, such as the particular shape selected, and the setup of this state is delayed (when _onmousedown_ fires) by 200ms using the _setTimeOut_ command. This command is saved to a numeric variable, and when the setup function fires, a semaphore value (_hasHappened_) is set to _true_. When the _onmousemove_ callback is activated, this semaphore is checked and if the flag is set to _true_, the current mouse coordinate is sent to the CanvasState, which maintains its own set of state which decides whether it is dragging a shape or drawing a new line. Upon _onmouseup_, the suspended action is cancelled (if it hasn't already occured), and dependent on the flag, a new shape is created, or the state setup for motion is torn down. This approach affords an efficient and simple solution to a potentially tricky problem.
    </li>
    <li> 
        Squares and Circles are drawn with particular canvas methods, as are basic lines. Arrows are more complicated, requiring the angle of the line to be ascertained using atan2 (a form of the arctan function) and two protruding lines needing to be measured using this angle and the desired offset from the end of the line. We believe that the result achieved is good, and the rotation invariance afforded to this method leads to uniformly good arrow rendering.
    </li>
    <li> 
        The selection of shapes for click and drag operations is effected through ascertaining an intersection between the incident point and a shape on the canvas. Finding the intersection with a circle or a square is basic geometry, and text selection is effected through a bounding box. Selecting a line, however, requires knowledge of each pixel upon which the the line is situated. Breshenham's rasterising algorithm is well suited to this purpose, finding the approximation (to the nearest pixel) of all points on a rendered 2D line. An image demonstrating Breshenham's algorithm is included below. We implemented Breshenham's algorithm, making it robust to lines of any angle through an approach based on the transposition of an arbitrary line to a particular frame of reference; between 0 and PI/4 radians above the origin, as suggested by the algorithm. Ascertaining intersection with a line relies on this interpolated list of pixels, as well as a 'halo' of 5 pixels either side (since accurately clicking on a 1px line was deemed too hard), and the end points are offset by the mouse movement. For arrows, the pixel values are also calculated for the head.
    </li>
    ![This is a demonstration of Breshenham's line algorithm](19)
    *Breshenham's:* The image shows the actual pixels that are covered by a rasterised line.
    
    <li> 
        The colour picker for the canvas is a PNG image painted onto a canvas element. While a user hovers over it, dynamic css bound with Angular is used to highlight the colour in a label, by retrieving the particular pixel value from the painted image.
    </li>
</ul>

The markdown editor uses as its front end the  [bootstrap-markdown-editor](https://github.com/inacho/bootstrap-markdown-editor), but is based on a custom markdown to HTML converter that works through a set of regex commands, with support indicated by the "Markdown Example Page". HTML can be embedded within the markdown, so as to enable more comprehensive styling than would be available with markdown alone. In order to prevent this being a severe security vulnerability, script HTML tags are removed. Something that we are particularly proud of is that users can reference images that they have created, which are loaded into scope and rendered as img tags using the data URI for that image. This report was written in our markdown editor, and the included image was drawn using our drawing tool. For other example pages, please head over to the home!
</ul>

We hope that you enjoy our site!


